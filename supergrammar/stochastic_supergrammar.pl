:-module(stochastic_supergrammar, [empty_production_rule/2
				  ,next_token/2
				  ,augmented_production/3
				  ]).

:-add_import_module(stochastic_supergrammar, supergrammar, start).

:-use_module(utilities).

%!	initial_score(?P) is det.
%
%      Starting score of a new production.
initial_score(-1).

/*
% generate_stochastic(_Rule_complexity,_Derivation_length,_Inference_limit,_Options):-
generate_stochastic(Example,Name,Score,Augmented):-
	clear_productions
	% take the next example
	,configuration:example_string(Example)
	% create a new rule
	% set its probability to 0
	,once(rule_name(Name))
	,initial_score(Score)
	% take the next token (terminal or nonterminal)
	,next_token(Example, Token)
	% augment the new rule
	,augmented_production(Name, [], [], [Score], Token, Augmented)
	% calculate its probability
	% compare the two probabilities
	% Choose a rule (new or old)
	% repeat from augment step
	% prune the examples
	% repeat from the top
	% exit if there are no more examples.
	.
*/

%!	empty_production_rule(-Production, -Probability) is det.
%
%	Production is a new, empty rule with the default initial
%	Probability.
%
%	Productions generated by empty_production_rule/2 are in the form
%	of DCG rules with a push-back list for probabilities.
%
empty_production_rule(H:-true, R):-
	once(rule_name(N))
	,initial_score(R)
	,dcg_translate_rule((N, [R] --> []), H:-true)
	,H =.. [N,[],[R]].


%!	empty_production_rule(P) is det.
%
%	True when P is a Prolog term representing the empty production,
%	(N, [R] --> [])
empty_production_rule(P:-true):-
	% An empty production has the default number of constituents
	% and the default initial score.
	initial_score(S)
	,P =..[_Name, [], [S]].


%!	empty_production(?Ypsilon) is nondet.
%
%	True when Ypsilon is a term:
%	(N, [R] --> [])
%
%	Representing the empty production, where N is a legal production
%	name and R the initial probability of a rule, as given by
%	initial_score/1.
empty_production((N, [R] --> [])):-
	var(N)
	,once(rule_name(N))
	,initial_score(R).

empty_production((N, [R] --> [])):-
	nonvar(N)
	,production_name(N)
	,initial_score(R).


%!	production_name(+Name) is det.
%
%	True when Name is a valid production name, conforming to the
%	expression:
%	==
%	[a-z][a-zA-Z0-9_]*
%	==
%
production_name(N):-
	must_be(nonvar, N)
	,atom_chars(N, [A|Atomic])
	,char_type(A, lower)
	,forall(member(C, Atomic), (char_type(C, alnum); C = '_')).


/*
augment_production(Production, Example, Augmented_production):-
	all_tokens(Example, Tokens)
	,augment_production(Production, Tokens, _, Augmented_production).

augment_production(Production, [Token], Augmented_production, Augmented_production):-
	augmented_production(Production, Token, Augmented_production).
augment_production(Production, [Token|Tokens], Temp, Acc):-
	augmented_production(Production,Token,Augmented_production)
	,augment_production(Augmented_production, Tokens, Temp, Acc).
*/

%!	next_token(+Example, -Token) is nondet.
%
%	Generates all terminals and nonterminals for augmenting a rule
%	on subsequent backtracking.
next_token(Example, Token):-
	must_be(nonvar, Example)
	,all_tokens(Example, Tokens)
	,member(Token, Tokens).


%!	all_tokens(+Example, -Tokens) is det.
%
%	Generate all tokens that are either part of Example or a
%	nonterminal in the grammar of the target language.
all_tokens(Example, Tokens):-
	findall(N
	       ,phrase(language, [N])
	       ,Nonterminals)
	,findall([T] % Add as terminals!
		,member(T, Example)
		,Terminals)
	,diff_list(Nonterminals, Nonterminals_diff, T1)
	,diff_list(Terminals, Terminals_diff, T2)
	,diff_append(Nonterminals_diff-T1, Terminals_diff-T2, Tokens-[]).


:-begin_tests(augmented_production).

test(augmented_production_augment_empty_production_with_a_nonterminal, [nondet]):-
	augmented_production(ypsilon, g1, (a0, [-1] --> g1)).

test(augmented_production_augment_empty_production_with_a_terminal, [nondet]):-
	augmented_production(ypsilon, [a], Production)
	,Production = (a0, [-1] --> [a]).

test(augmented_production_verify_augmenting_empty_production_with_a_nonterminal, [nondet]):-
	augmented_production(ypsilon, [a], (a0, [-1] --> [a])).

test(augmented_production_verify_augmenting_empty_production_with_a_terminal, [nondet]):-
	augmented_production(ypsilon, g1, (a0, [-1] --> g1)).

test(augmented_production_infer_nonterminal_from_empty_production_and_augmented_production, [nondet]):-
	augmented_production(ypsilon, Token, (a0, [-1] --> g1))
	,Token = g1.

test(augmented_production_infer_terminal_from_empty_production_and_augmented_production, [nondet]):-
	augmented_production(ypsilon, Token, (a0, [-1] --> [a]))
	,Token = [a].

test(augmented_production_infer_score_from_empty_production_and_augmented_production, [nondet]):-
	augmented_production(ypsilon, g1, (a0, Score --> g1))
	,Score = [-1].

test(augmented_production_augment_single_nonterminal_with_a_nonterminal,[nondet]):-
	augmented_production((a0, [-1] --> g1), g2, Augmented)
	,Augmented = (a0, [-1] --> g1, g2).

test(augmented_production_augment_single_nonterminal_with_a_terminal,[nondet]):-
	augmented_production((a0, [-1] --> g1), [a], Augmented)
	,Augmented = (a0, [-1] --> g1, [a]).

test(augmented_production_augment_nonterminals_with_a_nonterminal, [nondet]):-
	augmented_production((a0, [-1] --> g1, g2), g3, Augmented)
	,Augmented = (a0, [-1] --> g1, g2, g3).

test(augmented_production_augment_nonterminals_with_a_terminal, [nondet]):-
	augmented_production((a0, [-1] --> g1, g2), [a], Augmented)
	,Augmented = (a0, [-1] --> g1, g2, [a]).

test(augmented_production_augment_nonterminals_and_single_terminal_with_a_terminal):-
	augmented_production((a0, [-1] --> g1, g2, [a]), [b], Production)
	,Production = (a0, [-1] --> g1, g2, [a,b]).

test(augmented_production_augment_nonterminals_and_terminals_with_a_terminal):-
	augmented_production((a0, [-1] --> g1, g2, [a, b]), [c], Augmented)
	,Augmented = (a0, [-1] --> g1, g2, [a, b, c]).

test(augmented_production_augment_single_terminal_with_a_terminal
    ,[]):-
	augmented_production((a0, [-1] --> [a]), [b], Augmented)
	,Augmented = (a0, [-1] --> [a,b]).

% Illegal augmentations.

% Can't add nonterminals to right of terminal.
test(augmented_production_augment_nonterminals_and_single_terminal_with_a_nonterminal
    ,[blocked('Too much work'), fail]):-
	augmented_production((a0, [-1] --> g1, g2, g3, [a]), g4, _).

% Again: nonterminals may not follow a terminal
test(augmented_production_augment_nonterminals_and_terminals_with_a_nonterminal
    ,[blocked('Too much work'), fail]):-
	augmented_production((a0, [-1] --> g1, g2, [a, b]), g3, Augmented)
	,Augmented = (a0, [-1] --> g1, g2, g3, [a, b]).

% Nonterminals must precede terminals!
test(augmented_production_augment_single_terminal_with_a_nonterminal
    ,[blocked('Too much work'),fail]):-
	augmented_production((a0, [-1] --> [a]), g1, _).



:-end_tests(augmented_production).


%!	augmented_production(?Production, ?Token, ?Augmented) is nondet.
%
%	True when Production is a grammar rule in DCG notation, and
%	Augmented is the same rule augmented by the given Token.
%
%	Production can be the special atom ypsilon signifying the empty
%	production (as generated by empty_production/2):
%
%	(Name, [-1] --> [])
%
%	Otherwise, Production and Augmented are both in the form:
%
%	==
%	(Name, Score --> Nonterminals, Terminals)
%	==
%
%	Where:
%	* Name is a mix of atoms and numbers, for example as returned by
%	  rule_name/1
%	* Score is a list of integers, representing the probabilities of
%	  Production and each production in a single derivation of
%	  Production.
%	* Nonterminals is zero or more atomic names of nonterminals in
%	  the grammar of the target language, and
%	* Terminals is a list of zero or more atomic nameks of terminals
%	  in the grammar.
%
%	Token is a single terminal or nonterminal, where augmenting
%	Production using Token produces Augmented.
%
%	An atomic token (g1, g2, np, vp...) signifies a nonterminal,
%	whereas a token that is a list with a single element ([a], [b],
%	[abc]...) signifies a terminal.
%
%	augmented_production/3 can be used in mode (+,?,+) to find the
%	difference between two productions.
%
%	... well, it _should_ anyway :D
%
%	TODO: see fourth clause- I removed a whole branch and tests pass
%	anyway. This takes a lot of refactoring still.
%
augmented_production(ypsilon, Token, (Name, Score --> Token)):-
	empty_production((Name, Score --> [])).

augmented_production((Name, Score --> Tokens), Token, (Name, Score --> Augmented_tokens)):-
	is_list(Tokens)
	,(   Token = [_]
	 ->  once(append(Tokens, Token, Augmented_tokens))
	 ;   Token \= [_]
	    ,once(append([Token], Tokens, Augmented_tokens))
	 ).

% Current Tokens: one or more nonterminals.
augmented_production((Name, Score --> Tokens), Token, (Name, Score --> Tokens_tree)):-
	tree_list(Tokens, Tokens_list)
	,once(phrase(symbols(nonterminal,Nonterminals), Tokens_list, Rest))
	,once(phrase(symbols(terminal,[]), Rest, []))
	,once(append(Nonterminals, [Token], Augmented_nonterminals))
	,list_tree(Augmented_nonterminals, Tokens_tree).

% Current Tokens: one or more terminals
augmented_production((Name, Score --> Tokens), Token, (Name, Score --> Tokens_tree)):-
	tree_list(Tokens, Tokens_list)
	,once(phrase(symbols(nonterminal,Nonterminals), Tokens_list, [Rest]))
	,once(phrase(symbols(terminal,Terminals), Rest, []))

	,(   Token = [_] % Token is a terminal
	 ->  once(append(Terminals, Token, Augmented_terminals))
	    ,once(append(Nonterminals, [Augmented_terminals], New_tokens))
	 ;   true

	 % Watchit: this will never be true; don't you want to use \=?
	 %;   Token \== [_] % Token is a non-terminal; explicitly for clarity
	%->   once(append(Nonterminals, [Token], Augmented_nonterminals))
	 %   ,once(append(Augmented_nonterminals, Terminals, New_tokens))
	)

	,list_tree(New_tokens, Tokens_tree).



%!	production// is nondet.
%
%	The structure of a production.
production([H|Ts]) --> production_head(H), production_tokens(Ts).

%!	production_head// is nondet.
%
%	The head of a production consists of a rule name, a score and
%	the dcg arrow, -->.
production_head([N,S,A]) --> rule_name(N), score(S), dcg_arrow(A).

%!	production_tokens// is nondet.
%
%	Production tokens can be any number of nonterminal or terminal
%	symbols, the terminals following the nonterminals.
production_tokens([Ns|Ts]) --> symbols(nonterminal,Ns), symbols(terminal,Ts).

%!	rule_name(+Name) is nondet.
%
%	A valid rule name is defined by production_name/1
rule_name(Name) --> [Name], { production_name(Name) }.

%!	score// is nondet.
%
%	A score is a list of numbers.
score([[N]|Ns]) --> [[N]], { number(N)}, score(Ns).
score(_) --> [].

%!	dcg_arrow// is nondet.
%
%	The principal operator of dcgs.
dcg_arrow(-->) --> [-->].

%!	symbols// is nondet.
%
%	Symbols can be any number of terminals or nonterminals.
symbols(nonterminal,[S|Ss]) --> [S], {atom(S)}, symbols(nonterminal,Ss).
symbols(nonterminal,_) --> [].

symbols(terminal,[T|Ts]) --> [T], symbols(terminal,Ts).
%symbols(terminal,[T]) --> [T],{atom(T)}.
symbols(terminal,_) --> [].



%!	terms_functors(+Terms,?Tail,-Functors) is semidet.
%
%	Convert between a list of compound Terms and a tree of their
%	Functors. Tail is the tail of the tree and can be instantiated
%	to a variable to produce a cyclic term.
%
%	Used to extract the names of terminals from a rule body.
%
%	Example usages:
%
%	==
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,c,TFs).
%	TFs = (a, b, c).
%
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,V,TFs).
%	TFs = (a, b, V).
%
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,[],TFs).
%	TFs = (a, b, []).
%
%	?- Ts = a(A,B), terms_functors(Ts,b,TFs).
%	TFs = (a, b) ;
%	false.
%	==
%
terms_functors(Terms, Tail, Functors):-
	Terms =.. [','|Ts]
	,terms_functors_(Ts, Tail, Functors)
	,!.
terms_functors(Terms, Tail, Functors):-
	Terms =.. [F|_]
	,terms_functors_([F], Tail, Functors).


%!	terms_functors_(+Terms,?Tail,-Functors) is nondet.
%
%	Business end of terms_functors/3.
%
%	Example usages:
%
%	==
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,c,TFs)
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, c)
%	false.
%
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,Tail,TFs).
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, Tail) ;
%	false.
%
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,[],TFs).
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, []) ;
%	false.
%	==
%
terms_functors_([Term], Temp, (Functor,Temp)):-
	Term =.. [Functor|_Args].
terms_functors_([Term|Fs], Temp, Acc):-
	terms_functors_(Fs, Temp, Acc1)
	,terms_functors_([Term], Acc1, Acc).










