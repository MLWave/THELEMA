:-module(stochastic_supergrammar, [empty_production/2
				  ,next_token/2
				  ,augmented_production/3]).

:-add_import_module(stochastic_supergrammar, supergrammar, start).

:-use_module(utilities).

%!	initial_score(?P) is det.
%
%      Starting score of a new production.
initial_score(-1).


% generate_stochastic(_Rule_complexity,_Derivation_length,_Inference_limit,_Options):-
generate_stochastic(Example,Production,Score,Augmented):-
	clear_productions
	% take the next example
	,configuration:example_string(Example)
	% create a new rule
	% set its probability to 0
	,empty_production(Production, Score)
	% take the next token (terminal or nonterminal)
	,next_token(Example, Token)
	% augment the new rule
	,augmented_production(Production, Token, Augmented)
	% calculate its probability
	% compare the two probabilities
	% Choose a rule (new or old)
	% repeat from augment step
	% prune the examples
	% repeat from the top
	% exit if there are no more examples.
	.


%!	empty_production(-Production, -Probability) is det.
%
%	Production is a new, empty production with the default initial
%	Probability.
%
%	Productions generated by empty_production/2 are in the form of
%	DCG rules with a push-back list for probabilities.
%
empty_production(H:-true, R):-
	once(rule_name(N))
	,initial_score(R)
	,dcg_translate_rule((N, [R] --> []), H:-true)
	,H =.. [N,[],[R]].


empty_production(P:-true):-
	% An empty production has the default number of constituents
	% and the default initial score.
	initial_score(S)
	,P =..[_Name, [], [S]].


augment_production(Production, Example, Augmented_production):-
	all_tokens(Example, Tokens)
	,augment_production(Production, Tokens, _, Augmented_production).

augment_production(Production, [Token], Augmented_production, Augmented_production):-
	augmented_production(Production, Token, Augmented_production).
augment_production(Production, [Token|Tokens], Temp, Acc):-
	augmented_production(Production,Token,Augmented_production)
	,augment_production(Augmented_production, Tokens, Temp, Acc).


%!	next_token(+Example, -Token) is nondet.
%
%	Generates all terminals and nonterminals for augmenting a rule
%	on subsequent backtracking.
next_token(Example, Token):-
	must_be(nonvar, Example)
	,all_tokens(Example, Tokens)
	,member(Token, Tokens).


%!	all_tokens(+Example, -Tokens) is det.
%
%	Generate all tokens that are either part of Example or a
%	nonterminal in the grammar of the target language.
all_tokens(Example, Tokens):-
	findall(N
	       ,phrase(language, [N])
	       ,Nonterminals)
	,findall([T] % Add as terminals!
		,member(T, Example)
		,Terminals)
	,diff_list(Nonterminals, Nonterminals_diff, T1)
	,diff_list(Terminals, Terminals_diff, T2)
	,diff_append(Nonterminals_diff-T1, Terminals_diff-T2, Tokens-[]).



%!	augmented_production(+Production,+Token,-New_production) is nondet.
%
%	Augment the rule with a single terminal or nonterminal Inserts
%	that Token to the right end of the body of the given Production
%	rule, producting a New_production.
augmented_production((H:-true), [Token], Production):-
	H =.. [Name,[],Score]
	,dcg_translate_rule((Name, Score --> [Token]), Production)
	,!.
augmented_production((H:-true), [Token], Production):-
	H =.. [Name,Tokens,Score]
	,diff_list(Tokens,Tokens_diff, D)
	,diff_append(Tokens_diff-D, [Token]-[], Tt-[])
	,dcg_translate_rule((Name, Score --> Tt),Production)
	,!.
% Token is a nonterminal and the rule is only terminals.
augmented_production((H:-true), Token, Production):-
	H =.. [Name,Tokens,Score]
	% Ground the tokens list to avoid adding '$append'/3 call in body of rule.
	,diff_list(Tokens,Ground_tokens, [])
	,dcg_translate_rule((Name, Score --> Ground_tokens, Token),Production)
	,!.

% Token is a nonterminal and the rule has a mix of teminals and
% nonterminals
augmented_production((H:-((Terminals=Terminals,Nonterminals),Score=Score)), Token, Production):-
	H =.. [Name,Terminals,_]
	,terms_functors(Nonterminals, Token, Augmented_nonterminals)
	,diff_list(Terminals, Ground_terminals, [])
	,diff_list(Score, Ground_score, [])
	,dcg_translate_rule((Name, Ground_score --> Ground_terminals,Augmented_nonterminals),Production).



%!	terms_functors(+Terms,?Tail,-Functors) is semidet.
%
%	Convert between a list of compound Terms and a tree of their
%	Functors. Tail is the tail of the tree and can be instantiated
%	to a variable to produce a cyclic term.
%
%	Used to extract the names of terminals from a rule body.
%
%	Example usages:
%
%	==
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,c,TFs).
%	TFs = (a, b, c).
%
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,V,TFs).
%	TFs = (a, b, V).
%
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,[],TFs).
%	TFs = (a, b, []).
%
%	?- Ts = a(A,B), terms_functors(Ts,b,TFs).
%	TFs = (a, b) ;
%	false.
%	==
%
terms_functors(Terms, Tail, Functors):-
	Terms =.. [','|Ts]
	,terms_functors_(Ts, Tail, Functors)
	,!.
terms_functors(Terms, Tail, Functors):-
	Terms =.. [F|_]
	,terms_functors_([F], Tail, Functors).


%!	terms_functors_(+Terms,?Tail,-Functors) is nondet.
%
%	Business end of terms_functors/3.
%
%	Example usages:
%
%	==
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,c,TFs)
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, c)
%	false.
%
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,Tail,TFs).
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, Tail) ;
%	false.
%
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,[],TFs).
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, []) ;
%	false.
%	==
%
terms_functors_([Term], Temp, (Functor,Temp)):-
	Term =.. [Functor|_Args].
terms_functors_([Term|Fs], Temp, Acc):-
	terms_functors_(Fs, Temp, Acc1)
	,terms_functors_([Term], Acc1, Acc).





