:-module(stochastic_supergrammar, [generate_and_test/0
				   ,empty_production_rule/2
				  ,next_token/2
				  ,augmented_production/3
				  ]).

:-add_import_module(stochastic_supergrammar, supergrammar, start).

:-use_module(utilities).

%!	initial_score(?P) is det.
%
%      Starting score of a new production.
initial_score(-1).



generate_and_test:-
	clear_productions
	% generate_example
	,example_string(Example)
	% empty_production (implicit)
	% generate_token
	,all_tokens(Example, [T|Tokens])
%	% augment_production
	,once(augmented_production(ypsilon, T, Production))
	,generate_and_test(Tokens,Production,Final_production)
	% score_production
%	,production_score(Augmented, 0, Example, _Score)
	% finalize_production
	,finalize_production(Final_production, New_name)
	,writeln(finalized:Final_production-as:New_name)
%	,finalize_production(Augmented)
	% prune_corpus
	.

generate_and_test([], Production, Production).
generate_and_test([Token|Tokens], Production_temp, Acc):-
	augmented_production(Production_temp, Token, Augmented_production)
	,production_score(Augmented_production, Scored_production)
	,best_scored_production(Production_temp, Scored_production, Best_production)
	,generate_and_test(Tokens, Best_production, Acc).

production_score((Name, _S --> Body), (Name, [Score] --> Body)):-
	configuration:examples_module(M)
	,dcg_translate_rule((Name --> Body), (_H:-B))
	,findall(B
	       ,M:B
		,Parses)
	,length(Parses, Score).

%best_scored_production(Production, Augmented, Best_production).
best_scored_production((N1, [S1] --> B1), (_N2, [S2] --> _B2), (N1, [S1] --> B1)):-
	S1 >= S2
	,!.
best_scored_production(_, (N2, S2 --> B2), (N2, S2 --> B2)).

% Seems to be working OK.
finalize_production((Name, Score --> Body), (New_name, Score --> Body)):-
	dcg_translate_rule((Name, Score --> Body), (H:-B))
	,rename_rule((H:-B), New_name, Renamed_rule)
	% TESTING: ADD PROPER DERIVATION WHEN TESTED
	,add_new_production(New_name, Renamed_rule, [])
%	,writeln(renamed_rule:Name-as:New_name/Renamed_rule)
	.


/*
finalize_production(Production, Renamed_production):-
	Production = (_Name, Score --> Body)
	,Renamed_production = (New_name, Score --> Body)
	,once(rename_production(Production, Renamed_production))
	,dcg_translate_rule(Renamed_production, Renamed_rule)
	% TESTING: ADD PROPER DERIVATION WHEN TESTED
	,add_new_production(New_name, Renamed_rule, [])
	.

% Copy-pasta from supergrammar module.
rename_production((_, Score --> Body), (New_name, Score --> Body)):-
	rule_name(New_name)
	,configuration:examples_module(M)
	,\+ phrase(M:nonterminal, [New_name])
	.
*/

%!	empty_production_rule(-Production, -Probability) is det.
%
%	Production is a new, empty rule with the default initial
%	Probability.
%
%	Productions generated by empty_production_rule/2 are in the form
%	of DCG rules with a push-back list for probabilities.
%
empty_production_rule(H:-true, R):-
	once(rule_name(N))
	,initial_score(R)
	,dcg_translate_rule((N, [R] --> []), H:-true)
	,H =.. [N,[],[R]].


%!	empty_production_rule(P) is det.
%
%	True when P is a Prolog term representing the empty production,
%	(N, [R] --> [])
empty_production_rule(P:-true):-
	% An empty production has the default number of constituents
	% and the default initial score.
	initial_score(S)
	,P =..[_Name, [], [S]].


%!	empty_production(?Ypsilon) is nondet.
%
%	True when Ypsilon is a term:
%	(N, [R] --> [])
%
%	Representing the empty production, where N is a legal production
%	name and R the initial probability of a rule, as given by
%	initial_score/1.
empty_production((N, [R] --> [])):-
	var(N)
	,once(rule_name(N))
	% Need to check that rule name is unique.
	,initial_score(R).

empty_production((N, [R] --> [])):-
	nonvar(N)
	,production_name(N)
	,initial_score(R).


%!	production_name(+Name) is det.
%
%	True when Name is a valid production name, conforming to the
%	expression:
%	==
%	[a-z][a-zA-Z0-9_]*
%	==
%
production_name(N):-
	must_be(nonvar, N)
	,atom_chars(N, [A|Atomic])
	,char_type(A, lower)
	,forall(member(C, Atomic), (char_type(C, alnum); C = '_')).


%!	next_token(+Example, -Token) is nondet.
%
%	Generates all terminals and nonterminals for augmenting a rule
%	on subsequent backtracking.
next_token(Example, Token):-
	must_be(nonvar, Example)
	,all_tokens(Example, Tokens)
	,member(Token, Tokens).


%!	all_tokens(+Example, -Tokens) is det.
%
%	Generate all tokens that are either part of Example or a
%	nonterminal in the grammar of the target language.
all_tokens(Example, Tokens):-
	findall(N
	       ,phrase(language, [N])
	       ,Nonterminals)
	,findall([T] % Add as terminals!
		,member(T, Example)
		,Terminals)
	,diff_list(Nonterminals, Nonterminals_diff, T1)
	,diff_list(Terminals, Terminals_diff, T2)
	,diff_append(Nonterminals_diff-T1, Terminals_diff-T2, Tokens-[]).



%!	augmented_production(?Production, ?Token, ?Augmented) is nondet.
%
%	True when Production is a grammar rule in DCG notation, and
%	Augmented is the same rule augmented by the given Token.
%
%	Production can be the special atom ypsilon signifying the empty
%	production (as generated by empty_production/2):
%
%	(Name, [-1] --> [])
%
%	Otherwise, Production and Augmented are both in the form:
%
%	==
%	(Name, Score --> Nonterminals, Terminals)
%	==
%
%	Where:
%	* Name is a mix of atoms and numbers, for example as returned by
%	  rule_name/1
%	* Score is a list of integers, representing the probabilities of
%	  Production and each production in a single derivation of
%	  Production.
%	* Nonterminals is zero or more atomic names of nonterminals in
%	  the grammar of the target language, and
%	* Terminals is a list of zero or more atomic nameks of terminals
%	  in the grammar.
%
%	Token is a single terminal or nonterminal, where augmenting
%	Production using Token produces Augmented.
%
%	An atomic token (g1, g2, np, vp...) signifies a nonterminal,
%	whereas a token that is a list with a single element ([a], [b],
%	[abc]...) signifies a terminal.
%
%	augmented_production/3 can be used in mode (+,?,+) to find the
%	difference between two productions.
%
%	... well, it _should_ anyway :D
%
%	TODO: see fourth clause- I removed a whole branch and tests pass
%	anyway. This takes a lot of refactoring still.
%
augmented_production(ypsilon, Token, (Name, Score --> Token)):-
	empty_production((Name, Score --> [])).

augmented_production((Name, Score --> Body), Token, (Name, Score --> Augmented)):-
	tree_list(Body, Tokens)
	,once(phrase(symbols(nonterminal, Nonterminals), Tokens, Terminals))
	,augmented_production(Nonterminals, Terminals, Token, Tokens, Augmented).


%!	augmented_production(+Nonterminals,+Terminals,+Token,+Body,-Augmented)	is nondet.
%
%	Business end of augmented_production/3. Handles each separate
%	case of current production - new token in turn.
%
%	In general, there are three possible cases of a current
%	production and its augmentation:
%
%	| Current production |  Augmented production  |
%	| ------------------ |	--------------------  |
%	| []		     |	n \ t                 |
%	| n+		     |	n \ t                 |
%	| n* t+		     |	t                     |
%
%	The empty-production case is handled in the first clause of
%	augmented_production/3.
%
%	The remaining cases are broken down for convenience. In
%	particular, "n* t+ --> t" is handled by two clauses, one for "t
%	--> t", one for "n+ --> t" and one for "n+ t+ --> t".
%
%	As detailed in augmented_production/3 a nonterminal is never
%	allowed to follow a terminal.
%

% Case: n+ --> n | t (one or more terminals augmented by any token).
augmented_production([_|_], [], Token, Body, Augmented):-
	% Call with once/1 to avoid infinitely appending difflist Ns
	once(append(Body, [Token], Tokens))
	,list_tree(Tokens, Augmented).

% Case: t --> t (one terminal, augmented by one terminal)
augmented_production([], [[T]], [Token], _Body, Augmented):-
	once(append([T], [Token], Augmented))
	,!.

% Case: n+ t* --> t (one or more nonterminals followed by one or more
% terminals, augmented by one terminal.
augmented_production([N|Ns], [[T|Ts]], [Token], _Body, Augmented):-
	once(append([T|Ts], [Token], Terminals))
	,once(append([N|Ns], [Terminals], Tokens ))
	,list_tree(Tokens, Augmented).



%!	production// is nondet.
%
%	The structure of a production.
production([H|Ts]) --> production_head(H), production_tokens(Ts).

%!	production_head// is nondet.
%
%	The head of a production consists of a rule name, a score and
%	the dcg arrow, -->.
production_head([N,S,A]) --> rule_name(N), score(S), dcg_arrow(A).

%!	production_tokens// is nondet.
%
%	Production tokens can be any number of nonterminal or terminal
%	symbols, the terminals following the nonterminals.
production_tokens([Ns|Ts]) --> symbols(nonterminal,Ns), symbols(terminal,Ts).

%!	rule_name(+Name) is nondet.
%
%	A valid rule name is defined by production_name/1
rule_name(Name) --> [Name], { production_name(Name) }.

%!	score// is nondet.
%
%	A score is a list of numbers.
score([[N]|Ns]) --> [[N]], { number(N)}, score(Ns).
score(_) --> [].

%!	dcg_arrow// is nondet.
%
%	The principal operator of dcgs.
dcg_arrow(-->) --> [-->].

%!	symbols// is nondet.
%
%	Symbols can be any number of terminals or nonterminals.
symbols(nonterminal,[S|Ss]) --> [S], {atom(S)}, symbols(nonterminal,Ss).
symbols(nonterminal,_) --> [].

symbols(terminal,[T|Ts]) --> [T], symbols(terminal,Ts).
%symbols(terminal,[T]) --> [T],{atom(T)}.
symbols(terminal,_) --> [].



%!	terms_functors(+Terms,?Tail,-Functors) is semidet.
%
%	Convert between a list of compound Terms and a tree of their
%	Functors. Tail is the tail of the tree and can be instantiated
%	to a variable to produce a cyclic term.
%
%	Used to extract the names of terminals from a rule body.
%
%	Example usages:
%
%	==
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,c,TFs).
%	TFs = (a, b, c).
%
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,V,TFs).
%	TFs = (a, b, V).
%
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,[],TFs).
%	TFs = (a, b, []).
%
%	?- Ts = a(A,B), terms_functors(Ts,b,TFs).
%	TFs = (a, b) ;
%	false.
%	==
%
terms_functors(Terms, Tail, Functors):-
	Terms =.. [','|Ts]
	,terms_functors_(Ts, Tail, Functors)
	,!.
terms_functors(Terms, Tail, Functors):-
	Terms =.. [F|_]
	,terms_functors_([F], Tail, Functors).


%!	terms_functors_(+Terms,?Tail,-Functors) is nondet.
%
%	Business end of terms_functors/3.
%
%	Example usages:
%
%	==
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,c,TFs)
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, c)
%	false.
%
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,Tail,TFs).
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, Tail) ;
%	false.
%
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,[],TFs).
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, []) ;
%	false.
%	==
%
terms_functors_([Term], Temp, (Functor,Temp)):-
	Term =.. [Functor|_Args].
terms_functors_([Term|Fs], Temp, Acc):-
	terms_functors_(Fs, Temp, Acc1)
	,terms_functors_([Term], Acc1, Acc).










