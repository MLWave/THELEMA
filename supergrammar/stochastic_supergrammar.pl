:-module(stochastic_supergrammar, [empty_production/2
				  ,next_token/2
				  ,augmented_production/6]).

:-add_import_module(stochastic_supergrammar, supergrammar, start).

:-use_module(utilities).

%!	initial_score(?P) is det.
%
%      Starting score of a new production.
initial_score(-1).


% generate_stochastic(_Rule_complexity,_Derivation_length,_Inference_limit,_Options):-
generate_stochastic(Example,Name,Score,Augmented):-
	clear_productions
	% take the next example
	,configuration:example_string(Example)
	% create a new rule
	% set its probability to 0
	,once(rule_name(Name))
	,initial_score(Score)
	% take the next token (terminal or nonterminal)
	,next_token(Example, Token)
	% augment the new rule
	,augmented_production(Name, [], [], [Score], Token, Augmented)
	% calculate its probability
	% compare the two probabilities
	% Choose a rule (new or old)
	% repeat from augment step
	% prune the examples
	% repeat from the top
	% exit if there are no more examples.
	.


%!	empty_production(-Production, -Probability) is det.
%
%	Production is a new, empty production with the default initial
%	Probability.
%
%	Productions generated by empty_production/2 are in the form of
%	DCG rules with a push-back list for probabilities.
%
empty_production(H:-true, R):-
	once(rule_name(N))
	,initial_score(R)
	,dcg_translate_rule((N, [R] --> []), H:-true)
	,H =.. [N,[],[R]].


%!	empty_production(P) is det.
%
%	True when P is the empty production.
empty_production(P:-true):-
	% An empty production has the default number of constituents
	% and the default initial score.
	initial_score(S)
	,P =..[_Name, [], [S]].

/*
augment_production(Production, Example, Augmented_production):-
	all_tokens(Example, Tokens)
	,augment_production(Production, Tokens, _, Augmented_production).

augment_production(Production, [Token], Augmented_production, Augmented_production):-
	augmented_production(Production, Token, Augmented_production).
augment_production(Production, [Token|Tokens], Temp, Acc):-
	augmented_production(Production,Token,Augmented_production)
	,augment_production(Augmented_production, Tokens, Temp, Acc).
*/

%!	next_token(+Example, -Token) is nondet.
%
%	Generates all terminals and nonterminals for augmenting a rule
%	on subsequent backtracking.
next_token(Example, Token):-
	must_be(nonvar, Example)
	,all_tokens(Example, Tokens)
	,member(Token, Tokens).


%!	all_tokens(+Example, -Tokens) is det.
%
%	Generate all tokens that are either part of Example or a
%	nonterminal in the grammar of the target language.
all_tokens(Example, Tokens):-
	findall(N
	       ,phrase(language, [N])
	       ,Nonterminals)
	,findall([T] % Add as terminals!
		,member(T, Example)
		,Terminals)
	,diff_list(Nonterminals, Nonterminals_diff, T1)
	,diff_list(Terminals, Terminals_diff, T2)
	,diff_append(Nonterminals_diff-T1, Terminals_diff-T2, Tokens-[]).


:-begin_tests(augmented_production).

test(augmented_production_augment_empty_production_with_a_nonterminal):-
	dcg_translate_rule((a0, [-1] --> g1), R)
	,augmented_production(a0, [], [], [-1], g1, R).

test(augmented_production_augment_empty_production_with_a_terminal):-
	dcg_translate_rule((a0, [-1] --> [a]), R)
	,augmented_production(a0, [], [], [-1], [a], R).

test(augmented_production_augment_single_nonterminal_with_a_nonterminal):-
	dcg_translate_rule((a0, [-1] --> g1, g2), R)
	,augmented_production(a0, [g1|T]-T, [], [-1], g2, R).

test(augmented_production_augment_single_nonterminal_with_a_terminal):-
	dcg_translate_rule((a0, [-1] --> g1, [a]), R)
	,augmented_production(a0, [g1|T]-T, [], [-1], [a], R).

test(augmented_production_augment_nonterminals_with_a_nonterminal):-
	dcg_translate_rule((a0, [-1] --> g1, g2, g3), R)
	,augmented_production(a0, [g1,g2|T]-T, [], [-1], g3, R).

test(augmented_production_augment_nonterminals_with_a_terminal):-
	dcg_translate_rule((a0, [-1] --> g1, g2, [a]), R)
	,augmented_production(a0, [g1,g2|T]-T, [], [-1], [a], R).

test(augmented_production_augment_nonterminals_and_terminals_with_a_terminal):-
	dcg_translate_rule((a0, [-1] --> g1, g2, [a, b]), R)
	,augmented_production(a0, [g1,g2|T1]-T1, [a|T2]-T2, [-1], [b], R).

test(augmented_production_augment_nonterminals_and_terminals_with_a_nonterminal):-
	dcg_translate_rule((a0, [-1] --> g1, g2, g3, [a, b]), R)
	,augmented_production(a0, [g1,g2|T1]-T1, [a,b|T2]-T2, [-1], g3, R).

:-end_tests(augmented_production).


%!	augmented_production(+Name,+Nonterminals,+Terminals,+Score,+Token,-New_production) is det.
%
%	Augment the Named production with a single terminal or
%	nonterminal.
%
%       Inserts that Token to the right end of the body of
%	the Named rule, producting a New_production.
%
%	Nonterminals and Terminals are difference lists with a
%	tail-variable attached, for example:
%	[g1,g2|T]-T
%
%	Score is the scoring value of the Named rule to be preserved in
%	the New_production.
%
augmented_production(Name, [], [], Score, Token, Production):-
	dcg_translate_rule((Name, Score --> Token), Production)
	,!.

augmented_production(Name, Ns, [], Score, Token, Production):-
	diff_append(Ns, [Token]-[], Ts-[])
	,list_tree(Ts, Tokens)
	,dcg_translate_rule((Name, Score --> Tokens), Production)
	,!.

augmented_production(Name, Ns, Ts, Score, [T], Production):-
	diff_append(Ts, [T]-[], Terminals-[])
	,diff_append(Ns, [Terminals]-[], Tokens-[])
	,list_tree(Tokens, Body)
	,dcg_translate_rule((Name, Score --> Body), Production)
	,!.

augmented_production(Name, Ns, Ts, Score, Token, Production):-
	diff_append(Ts, []-[], Terminals-[])
	,diff_append(Ns, [Token|T]-T, Tokens-[Terminals])
	,list_tree(Tokens, Body)
	,dcg_translate_rule((Name, Score --> Body), Production).



%!	terms_functors(+Terms,?Tail,-Functors) is semidet.
%
%	Convert between a list of compound Terms and a tree of their
%	Functors. Tail is the tail of the tree and can be instantiated
%	to a variable to produce a cyclic term.
%
%	Used to extract the names of terminals from a rule body.
%
%	Example usages:
%
%	==
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,c,TFs).
%	TFs = (a, b, c).
%
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,V,TFs).
%	TFs = (a, b, V).
%
%	?- Ts = (a(A,B),b(C,D)), terms_functors(Ts,[],TFs).
%	TFs = (a, b, []).
%
%	?- Ts = a(A,B), terms_functors(Ts,b,TFs).
%	TFs = (a, b) ;
%	false.
%	==
%
terms_functors(Terms, Tail, Functors):-
	Terms =.. [','|Ts]
	,terms_functors_(Ts, Tail, Functors)
	,!.
terms_functors(Terms, Tail, Functors):-
	Terms =.. [F|_]
	,terms_functors_([F], Tail, Functors).


%!	terms_functors_(+Terms,?Tail,-Functors) is nondet.
%
%	Business end of terms_functors/3.
%
%	Example usages:
%
%	==
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,c,TFs)
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, c)
%	false.
%
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,Tail,TFs).
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, Tail) ;
%	false.
%
%	?- (a(A,B), b(C,D)) =.. [','|Ts], terms_functors(Ts,[],TFs).
%	Ts = [a(A, B), b(C, D)],
%	TFs = (a, b, []) ;
%	false.
%	==
%
terms_functors_([Term], Temp, (Functor,Temp)):-
	Term =.. [Functor|_Args].
terms_functors_([Term|Fs], Temp, Acc):-
	terms_functors_(Fs, Temp, Acc1)
	,terms_functors_([Term], Acc1, Acc).





